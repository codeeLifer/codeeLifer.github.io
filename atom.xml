<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://codeeLifer.github.io</id>
    <title>Gridea</title>
    <updated>2021-08-13T06:23:18.548Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://codeeLifer.github.io"/>
    <link rel="self" href="https://codeeLifer.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://codeeLifer.github.io/images/avatar.png</logo>
    <icon>https://codeeLifer.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[如何打破双亲委派类加载模型？]]></title>
        <id>https://codeeLifer.github.io/post/ru-he-da-po-shuang-qin-wei-pai-lei-jia-zai-mo-xing/</id>
        <link href="https://codeeLifer.github.io/post/ru-he-da-po-shuang-qin-wei-pai-lei-jia-zai-mo-xing/">
        </link>
        <updated>2021-08-13T06:20:58.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p><strong>使用线程上下文类加载器</strong></p>
</li>
<li>
<p>双亲委托机制以及类加载器的问题</p>
<ul>
<li>
<p>一般情况下，保证同一个类中所关联的其他类都是由当前类的类加载器所加载的。比如，ClassA本身在Ext下找到，那么他里面new出来的一些类也就只能用Ext去查找了（不会低一个级别），所以有些明明App可以找到的，却找不到了。</p>
</li>
<li>
<p>JDBC API，他有实现的driven部分（mysql/sql server），我们的JDBC API都是由Boot或者Ext来载入的，但是JDBC driver却是由Ext或者App来载入，那么就有可能找不到driver了（<strong>因为驱动类是第三方厂商实现的，他们的包并没有与接口类放在一起，因此启动类与扩展类加载器找不到该类，从而导致加载失败</strong>）。在Java领域中，其实只要分成这种Api+SPI（Service Provide Interface，特定厂商提供）的，都会遇到此问题，常见的SPI有JDBC、JCE、JNDI、JAXP和JBI等。这些SPI的接口由Java核心库来提供，如JAXP的SPI接囗定义包含在javax.xml.parsers包中，SPI的接口是Java核心库的一部分，是由引导类加载器来加载的；SPI实现的Java类一般是由系统类加载器来加载的。引导类加载器是无法找到SPI的实现类的，因为它只加载Java的核心。</p>
</li>
</ul>
</li>
<li>
<p>通常当你需要动态加载资源的时候，你至少有三个ClassLoader可以选择：<br>
1. 系统类加载器或叫作应用类加载器（system classloader or application classloader）<br>
2.  当前类加载器<br>
3.  当前线程类加载器</p>
</li>
<li>
<p>线程类加载器是为了抛弃双亲委派加载链模式。每个线程都有一个关联的上下文类加载器。如果你使用new Thread0方式生成新的线程，新线程将继承其父线程的上下文类加载器。如果程序对线程上下文类加载器没有任何改动的话，程序中所有的线程将都使用系统类加载器作为上下文类加载器。<br>
Thread.currentThread0.getContextClassLoader（）<br>
Thread.currentThread0.setContextClassLoader（）</p>
</li>
<li>
<p>如何不对当前线程的类加载器设置的话，则当前线程的默认加载器默认是应用类加载器ApplicationContextClassLoader</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Cookie与Session]]></title>
        <id>https://codeeLifer.github.io/post/cookie-yu-session/</id>
        <link href="https://codeeLifer.github.io/post/cookie-yu-session/">
        </link>
        <updated>2021-08-11T07:58:33.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>会话：一次会话中包含多次请求和响应。</p>
<ul>
<li>一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止</li>
</ul>
</li>
<li>
<p>功能：在一次会话的范围内的多次请求间，共享数据</p>
</li>
<li>
<p>方式：</p>
<ol>
<li>客户端会话技术：Cookie</li>
<li>服务器端会话技术：Session</li>
</ol>
</li>
<li>
<p>Cookie快速入门：</p>
<ul>
<li>使用步骤：
<ol>
<li>创建Cookie对象，绑定数据
<ul>
<li>new Cookie(String name, String value)</li>
</ul>
</li>
<li>发送Cookie对象
<ul>
<li>response.addCookie(Cookie cookie)</li>
</ul>
</li>
<li>获取Cookie，拿到数据
<ul>
<li>Cookie[]  request.getCookies()</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>实现原理</p>
<ul>
<li>基于响应头set-cookie和请求头cookie实现</li>
</ul>
</li>
<li>
<p>cookie的细节</p>
<ol>
<li>一次可不可以发送多个cookie?
<ul>
<li>可以</li>
<li>可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。</li>
</ul>
</li>
<li>cookie在浏览器中保存多长时间？
<ol>
<li>默认情况下，当浏览器关闭后，Cookie数据被销毁</li>
<li>持久化存储：
<ul>
<li>setMaxAge(int seconds)
<ol>
<li>正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效</li>
<li>负数：默认值</li>
<li>零：删除cookie信息</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li>cookie能不能存中文？
<ul>
<li>在tomcat 8 之前 cookie中不能直接存储中文数据。
<ul>
<li>需要将中文数据转码---一般采用URL编码(%E3)</li>
</ul>
</li>
<li>在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析</li>
</ul>
</li>
<li>cookie共享问题？
<ol>
<li>假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？
<ul>
<li>默认情况下cookie不能共享</li>
<li>setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目</li>
<li>如果要共享，则可以将path设置为&quot;/&quot;</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>不同的tomcat服务器间cookie共享问题？<br>
* setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享<br>
* <strong>setDomain(&quot;.baidu.com&quot;),那么tieba.baidu.com和news.baidu.com中cookie可以共享</strong></p>
</li>
<li>
<p>Cookie的特点和作用</p>
<ol>
<li>cookie存储数据在客户端浏览器</li>
<li>浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个)</li>
</ol>
<ul>
<li>作用：
<ol>
<li>cookie一般用于存出少量的不太敏感的数据</li>
<li>在不登录的情况下，完成服务器对客户端的身份识别</li>
</ol>
</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RSA算法——使用私钥签名，公钥验签]]></title>
        <id>https://codeeLifer.github.io/post/rsa-suan-fa-shi-yong-si-yao-qian-ming-gong-yao-yan-qian/</id>
        <link href="https://codeeLifer.github.io/post/rsa-suan-fa-shi-yong-si-yao-qian-ming-gong-yao-yan-qian/">
        </link>
        <updated>2021-08-11T01:11:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-加密技术">1 加密技术</h1>
<h2 id="11-对称加密与非对称加密">1.1 对称加密与非对称加密</h2>
<ul>
<li>加密技术是最常见的安全保密手段，数据加密技术的关键在于加密/解密算法和密钥管理。数据加密的基本过程是对原来为明文的文件或数据按某种加密算法进行处理，使其成为不可读的一段代码，通常称为“密文”。“密文”只能在输入相应的密钥之后才能显示出原来的内容，通过这样的途径保证被加密的内容不被窃取。</li>
<li>对称加密的特点是文件或数据加密和解密使用相同的密钥，这种方法在密码学中称为对称加密算法。 非对称加密算法区别于对称加密算法，非对称加密算法需要两个密钥，公钥（Publickey）和私钥（PrivateKey）。公钥与私钥是一对，如果使用公钥对数据加密，需要对应的私钥才能解密；如果使用私钥对数据加密，需要对应的公钥才能解密。</li>
</ul>
<h2 id="12-加密与签名">1.2 加密与签名</h2>
<ul>
<li>非对称加密有两种用法。第一种用法是公钥加密、私钥解密——用于加密；第二种用法是私钥签名、公钥验签——用于签名。</li>
<li>什么时候用公钥，什么时候用私钥是经常被问起的问题。</li>
<li>第一种情况，当用于加密时，肯定是不想让别人知道我加密的内容，此时用于解密的肯定是私钥。比如A需要B发送一个加密后的数据过来，B知道A的公钥，C也知道A的公钥，A将数据使用A的公钥加密后发送出去，A获得了加密后的数据并用A的私钥解密，而如果C也想获取这一个数据，但是C没有A的私钥也是获取不了的。</li>
<li>第二种情况，用于签名。这里签名的意思是证明这个数据时由“我”发出的，要证明这一个数据由“我”发出，那肯定要用私钥加密，也就是签名，其他人获取这一加密数据后用“我”的公钥解密，也就是校验这一个签名。这里举一个例子，在一个“商城系统”微服务中，客户端请求用户认证微服务，获取到了一个私钥加密的token，这个token就是“商城系统”的签名，拿到这一个token的客户端携带token访问“商城系统”的其他微服务，其他微服务对这个客户端的请求进行拦截并使用“商城系统”的公钥校验token，如果通过验证才允许请求继续进行。</li>
</ul>
<h2 id="13-使用spring-security实现私钥签名公钥验签功能">1.3 使用Spring Security实现私钥签名，公钥验签功能</h2>
<ul>
<li>私钥签名</li>
</ul>
<pre><code>    /**
     * 读取证书文件中的私钥，并使用私钥对数据加密，得到加密后的字符串
     */    
    @Test
    public void testGenerateToken(){
        String keystore = &quot;mountain.keystore&quot;;
        String keystorePassword = &quot;mountainkeystore&quot;;
        ClassPathResource classPathResource = new ClassPathResource(keystore);
        String alias  = &quot;mountainkey&quot;;
        String keyPassword = &quot;mountain&quot;;
        KeyStoreKeyFactory keyStoreKeyFactory = new KeyStoreKeyFactory(classPathResource,keystorePassword.toCharArray());
        KeyPair keyPair = keyStoreKeyFactory.getKeyPair(alias, keyPassword.toCharArray());
        RSAPrivateKey aPrivate = (RSAPrivateKey) keyPair.getPrivate();
        Map&lt;String,String&gt; contentMap = new HashMap&lt;&gt;();
        contentMap.put(&quot;hello&quot;,&quot;hello world&quot;);
        String bodyString = JSON.toJSONString(contentMap);
        Jwt jwt = JwtHelper.encode(bodyString, new RsaSigner(aPrivate));
        String encodedContent = jwt.getEncoded();
        System.out.println(encodedContent);
    }
</code></pre>
<ul>
<li>公钥验签</li>
</ul>
<pre><code>    /**
     * 使用公钥校验加密后的字符串
     */
    @Test
    public void testCheckTokenByPublicKey() {
        // 公钥
        String publickey = &quot;-----BEGIN PUBLIC KEY-----&quot; +
                &quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtbuddIbMU5FjqpJR4Ikn&quot; +
                &quot;xktq1k/0C10XfOR2VU79qh4PXGSNn6Vt5BZgK8Ow4cA7SzAMoBUkxev/5I2Mx4p4&quot; +
                &quot;gk+6ImQ+IsTi6tqXOQ7DHjpogfsX/VeXJ93Aeq8v9hOqtKYj5q1jy4skGRvbD+c8&quot; +
                &quot;Z6knxLQb9I6HE39v3BZZL+WTYz6kx8BTZ0rPd7C5uOVqYo/FG+QzY+Ndv2u7gNcy&quot; +
                &quot;V9sRnM+hI2w5e87LuG+V6GhekdKqtS0dsjKskpjX/L2ppykdi1hkCtS/ipZ5aaAj&quot; +
                &quot;/SzVfWfQTxw4Yh+3QVc+KoSW61KlCZ+SSu7YrszAqlg93927/eWWLjYUFsCqP0jw&quot; +
                &quot;5wIDAQAB&quot; +
                &quot;-----END PUBLIC KEY-----&quot;;
        // 私钥加密后的内容
        String token = &quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJoZWxsbyI6ImhlbGxvIHdvcmxkIn0.LNB7GpiTYl1G4MNYpFDPgay6funMLXeoGUo3TU30IfhIJiSU7zobJ-SpJap6ARbCJoRc5_JURb4ti-6vanf3cpIyOayk2H83gfBOSY8_wACbpfhlt_PGT0RYfStGC7OVwKFUAdEaO6hYYD466vI8d6d9uNb1RfNfGToYlosH05McYAyrM2XLcy0T7glZmuNw_JgMflRAjN09K13MlQZttn6W-lhSlv38CE1_CJ8SzNLHC6U7Dzd1FlcW9Xs-IvDalw1xzgzNRfbNpdvcZTnNhbdNa6_bSlSIfSM9IHngG3EVS_hwQkGOfBeV5gxQZrW4BB9niK8FwvoDB1cVjy4Ktw&quot;;
        //校验jwt令牌
        Jwt jwt = JwtHelper.decodeAndVerify(token, new RsaVerifier(publickey));
        //拿到jwt令牌中自定义的内容
        String claims = jwt.getClaims();
        System.out.println(claims);
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[跨域与如何解决跨域问题]]></title>
        <id>https://codeeLifer.github.io/post/kua-yu-yu-ru-he-jie-jue-kua-yu-wen-ti/</id>
        <link href="https://codeeLifer.github.io/post/kua-yu-yu-ru-he-jie-jue-kua-yu-wen-ti/">
        </link>
        <updated>2021-08-09T07:41:51.000Z</updated>
        <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:left">URL</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">是否允许通信</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">http://www.a.com/a.js http://www.a.com/b.js</td>
<td style="text-align:left">同一域名下</td>
<td style="text-align:left">允许</td>
</tr>
<tr>
<td style="text-align:left">http://www.a.com/lab/a.js http://www.a.com/script/b.js</td>
<td style="text-align:left">同一域名下不同文件夹</td>
<td style="text-align:left">允许</td>
</tr>
<tr>
<td style="text-align:left">http://www.a.com:8000/a.js http://www.a.com/b.js</td>
<td style="text-align:left">同一域名，不同端口</td>
<td style="text-align:left">不允许</td>
</tr>
<tr>
<td style="text-align:left">http://www.a.com/a.js https://www.a.com/b.js</td>
<td style="text-align:left">同一域名，不同协议</td>
<td style="text-align:left">不允许</td>
</tr>
<tr>
<td style="text-align:left">http://www.a.com/a.js http://70.32.92.74/b.js</td>
<td style="text-align:left">域名和域名对应ip</td>
<td style="text-align:left">不允许</td>
</tr>
<tr>
<td style="text-align:left">http://www.a.com/a.js http://script.a.com/b.js</td>
<td style="text-align:left">主域相同，子域不同</td>
<td style="text-align:left">不允许</td>
</tr>
<tr>
<td style="text-align:left">http://www.a.com/a.js http://a.com/b.js</td>
<td style="text-align:left">同一域名，不同二级域名（同上）</td>
<td style="text-align:left">不允许（cookie这种情况下也不允许访问）</td>
</tr>
<tr>
<td style="text-align:left">http://www.cnblogs.com/a.js http://www.a.com/b.js</td>
<td style="text-align:left">不同域名</td>
<td style="text-align:left">不允许</td>
</tr>
</tbody>
</table>
<p>解决办法：</p>
<pre><code class="language-java">package net.youqu.micro.service.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.reactive.CorsWebFilter;
import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;
import org.springframework.web.util.pattern.PathPatternParser;

/**
 * description:
 *
 * @author slh
 * @date 2021.01.10
 */
@Configuration
public class CorsConfig {
    @Bean
    public CorsWebFilter corsFilter() {
        CorsConfiguration config = new CorsConfiguration();
        config.addAllowedMethod(&quot;*&quot;);
        config.addAllowedOrigin(&quot;*&quot;);
        config.addAllowedHeader(&quot;*&quot;);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(new PathPatternParser());
        source.registerCorsConfiguration(&quot;/**&quot;, config);

        return new CorsWebFilter(source);
    }
}


spring:
  cloud:
    gateway:
      discovery:
      # 跨域
      globalcors:
        corsConfigurations:
          '[/**]':
            allowedHeaders: &quot;*&quot;
            allowedOrigins: &quot;*&quot;
            allowedMethods:
            - GET
              POST
              DELETE
              PUT
              OPTION
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DFS算法总结 ]]></title>
        <id>https://codeeLifer.github.io/post/dfs-lei-suan-fa-ti-zong-jie/</id>
        <link href="https://codeeLifer.github.io/post/dfs-lei-suan-fa-ti-zong-jie/">
        </link>
        <updated>2021-08-09T07:09:47.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://codeeLifer.github.io/post-images/1628493334019.jpg" alt="" loading="lazy"></figure>
<ol>
<li>矩阵中的路径<br>
给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。<br>
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。<br>
例如，在下面的 3×4 的矩阵中包含单词 &quot;ABCCED&quot;（单词中的字母已标出）。</li>
</ol>
<p>示例 1：<br>
输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]],<br>
word = &quot;ABCCED&quot;<br>
输出：true</p>
<pre><code class="language-java">javaimport java.util.HashMap;
public class Solution {
    public static void main(String[] args) {
        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();
        char[][] board = {
//                {'A', 'B', 'C', 'E'},
//                {'S', 'F', 'C', 'S'},
//                {'A', 'D', 'E', 'F'}
                {'a','b'}
        };
        Solution solution = new Solution();
        boolean bcfc = solution.exist(board, &quot;ba&quot;);
        System.out.println(bcfc);
    }
    public boolean exist(char[][] board, String word) {
        //初始化访问标记
        boolean[][] visited = new boolean[board.length][board[0].length];
        for (int i = 0; i &lt; board.length; i++) {
            for (int j = 0; j &lt; board[0].length; j++) {
                visited[i][j] = false;
            }
        }

        for (int i = 0; i &lt; board.length; i++) {
            for (int j = 0; j &lt; board[0].length; j++) {
                if (dfs(board,i,j,word,0,visited)) {
                    return true;
                }
            }
        }
        return false;
    }

    public boolean dfs(char[][] board, int x, int y, String word, int pathLength, boolean[][] visited) {
     

        if (pathLength == word.length()) {
            return true;
        }

        boolean flag = false;
        if (x &gt;= 0 &amp;&amp; x &lt; board.length &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; board[0].length &amp;&amp; word.charAt(pathLength) == board[x][y] &amp;&amp; !visited[x][y]) {
            pathLength++;
            visited[x][y] = true;

            System.out.println(board[x][y]);

            flag = dfs(board, x + 1, y, word, pathLength, visited) ||
                    dfs(board, x, y + 1, word, pathLength, visited) ||
                    dfs(board, x - 1, y, word, pathLength, visited) ||
                    dfs(board, x, y - 1, word, pathLength, visited);

            visited[x][y] = false;
        }
        return flag;
    }
}
</code></pre>
<ol start="2">
<li>不同路径<br>
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br>
问总共有多少条不同的路径？<br>
<img src="https://codeeLifer.github.io/post-images/1628512694119.PNG" alt="" loading="lazy"></li>
</ol>
<pre><code>class Solution {
    public int uniquePaths(int m, int n) {
        Map&lt;String,Integer&gt; resultMap = new HashMap&lt;&gt;();
        return dfs(resultMap,1,1,m,n);
    }
    public int dfs(Map&lt;String, Integer&gt; map,int x ,int y,int m ,int n){
        String s = x + &quot;*&quot; +  y;
        if(map.containsKey(s)){
            return map.get(s);
        }
        if(x &gt; m || y &gt; n ){
            return 0;
        }
        if(x == m &amp;&amp; y == n){
            return 1;
        }
        int result = dfs(map,x+1,y,m,n) + dfs(map,x,y+1,m,n);
        map.put(s,result);
        return result;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java面试重点]]></title>
        <id>https://codeeLifer.github.io/post/java-mian-shi-chong-dian/</id>
        <link href="https://codeeLifer.github.io/post/java-mian-shi-chong-dian/">
        </link>
        <updated>2021-07-24T11:51:59.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>Java基础面试专题<br>
<a href="https://codeelifer.github.io/post/java-ji-chu-mian-shi-chong-dian/">1. java基础</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello poolMan!]]></title>
        <id>https://codeeLifer.github.io/post/hello-gridea/</id>
        <link href="https://codeeLifer.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://github.com/codeeLifer">我的GitHub</a><br>
<a href="https://codeeLifer.github.io">博客主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
]]></content>
    </entry>
</feed>