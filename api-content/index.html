{"posts":[{"title":"Cookie与Session","content":" 会话：一次会话中包含多次请求和响应。 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 功能：在一次会话的范围内的多次请求间，共享数据 方式： 客户端会话技术：Cookie 服务器端会话技术：Session Cookie快速入门： 使用步骤： 创建Cookie对象，绑定数据 new Cookie(String name, String value) 发送Cookie对象 response.addCookie(Cookie cookie) 获取Cookie，拿到数据 Cookie[] request.getCookies() 实现原理 基于响应头set-cookie和请求头cookie实现 cookie的细节 一次可不可以发送多个cookie? 可以 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。 cookie在浏览器中保存多长时间？ 默认情况下，当浏览器关闭后，Cookie数据被销毁 持久化存储： setMaxAge(int seconds) 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效 负数：默认值 零：删除cookie信息 cookie能不能存中文？ 在tomcat 8 之前 cookie中不能直接存储中文数据。 需要将中文数据转码---一般采用URL编码(%E3) 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析 cookie共享问题？ 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？ 默认情况下cookie不能共享 setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目 如果要共享，则可以将path设置为&quot;/&quot; 不同的tomcat服务器间cookie共享问题？ * setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享 * setDomain(&quot;.baidu.com&quot;),那么tieba.baidu.com和news.baidu.com中cookie可以共享 Cookie的特点和作用 cookie存储数据在客户端浏览器 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) 作用： cookie一般用于存出少量的不太敏感的数据 在不登录的情况下，完成服务器对客户端的身份识别 ","link":"https://codeeLifer.github.io/post/cookie-yu-session/"},{"title":"RSA算法——使用私钥签名，公钥验签","content":"1 加密技术 1.1 对称加密与非对称加密 加密技术是最常见的安全保密手段，数据加密技术的关键在于加密/解密算法和密钥管理。数据加密的基本过程是对原来为明文的文件或数据按某种加密算法进行处理，使其成为不可读的一段代码，通常称为“密文”。“密文”只能在输入相应的密钥之后才能显示出原来的内容，通过这样的途径保证被加密的内容不被窃取。 对称加密的特点是文件或数据加密和解密使用相同的密钥，这种方法在密码学中称为对称加密算法。 非对称加密算法区别于对称加密算法，非对称加密算法需要两个密钥，公钥（Publickey）和私钥（PrivateKey）。公钥与私钥是一对，如果使用公钥对数据加密，需要对应的私钥才能解密；如果使用私钥对数据加密，需要对应的公钥才能解密。 1.2 加密与签名 非对称加密有两种用法。第一种用法是公钥加密、私钥解密——用于加密；第二种用法是私钥签名、公钥验签——用于签名。 什么时候用公钥，什么时候用私钥是经常被问起的问题。 第一种情况，当用于加密时，肯定是不想让别人知道我加密的内容，此时用于解密的肯定是私钥。比如A需要B发送一个加密后的数据过来，B知道A的公钥，C也知道A的公钥，A将数据使用A的公钥加密后发送出去，A获得了加密后的数据并用A的私钥解密，而如果C也想获取这一个数据，但是C没有A的私钥也是获取不了的。 第二种情况，用于签名。这里签名的意思是证明这个数据时由“我”发出的，要证明这一个数据由“我”发出，那肯定要用私钥加密，也就是签名，其他人获取这一加密数据后用“我”的公钥解密，也就是校验这一个签名。这里举一个例子，在一个“商城系统”微服务中，客户端请求用户认证微服务，获取到了一个私钥加密的token，这个token就是“商城系统”的签名，拿到这一个token的客户端携带token访问“商城系统”的其他微服务，其他微服务对这个客户端的请求进行拦截并使用“商城系统”的公钥校验token，如果通过验证才允许请求继续进行。 1.3 使用Spring Security实现私钥签名，公钥验签功能 私钥签名 /** * 读取证书文件中的私钥，并使用私钥对数据加密，得到加密后的字符串 */ @Test public void testGenerateToken(){ String keystore = &quot;mountain.keystore&quot;; String keystorePassword = &quot;mountainkeystore&quot;; ClassPathResource classPathResource = new ClassPathResource(keystore); String alias = &quot;mountainkey&quot;; String keyPassword = &quot;mountain&quot;; KeyStoreKeyFactory keyStoreKeyFactory = new KeyStoreKeyFactory(classPathResource,keystorePassword.toCharArray()); KeyPair keyPair = keyStoreKeyFactory.getKeyPair(alias, keyPassword.toCharArray()); RSAPrivateKey aPrivate = (RSAPrivateKey) keyPair.getPrivate(); Map&lt;String,String&gt; contentMap = new HashMap&lt;&gt;(); contentMap.put(&quot;hello&quot;,&quot;hello world&quot;); String bodyString = JSON.toJSONString(contentMap); Jwt jwt = JwtHelper.encode(bodyString, new RsaSigner(aPrivate)); String encodedContent = jwt.getEncoded(); System.out.println(encodedContent); } 公钥验签 /** * 使用公钥校验加密后的字符串 */ @Test public void testCheckTokenByPublicKey() { // 公钥 String publickey = &quot;-----BEGIN PUBLIC KEY-----&quot; + &quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtbuddIbMU5FjqpJR4Ikn&quot; + &quot;xktq1k/0C10XfOR2VU79qh4PXGSNn6Vt5BZgK8Ow4cA7SzAMoBUkxev/5I2Mx4p4&quot; + &quot;gk+6ImQ+IsTi6tqXOQ7DHjpogfsX/VeXJ93Aeq8v9hOqtKYj5q1jy4skGRvbD+c8&quot; + &quot;Z6knxLQb9I6HE39v3BZZL+WTYz6kx8BTZ0rPd7C5uOVqYo/FG+QzY+Ndv2u7gNcy&quot; + &quot;V9sRnM+hI2w5e87LuG+V6GhekdKqtS0dsjKskpjX/L2ppykdi1hkCtS/ipZ5aaAj&quot; + &quot;/SzVfWfQTxw4Yh+3QVc+KoSW61KlCZ+SSu7YrszAqlg93927/eWWLjYUFsCqP0jw&quot; + &quot;5wIDAQAB&quot; + &quot;-----END PUBLIC KEY-----&quot;; // 私钥加密后的内容 String token = &quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJoZWxsbyI6ImhlbGxvIHdvcmxkIn0.LNB7GpiTYl1G4MNYpFDPgay6funMLXeoGUo3TU30IfhIJiSU7zobJ-SpJap6ARbCJoRc5_JURb4ti-6vanf3cpIyOayk2H83gfBOSY8_wACbpfhlt_PGT0RYfStGC7OVwKFUAdEaO6hYYD466vI8d6d9uNb1RfNfGToYlosH05McYAyrM2XLcy0T7glZmuNw_JgMflRAjN09K13MlQZttn6W-lhSlv38CE1_CJ8SzNLHC6U7Dzd1FlcW9Xs-IvDalw1xzgzNRfbNpdvcZTnNhbdNa6_bSlSIfSM9IHngG3EVS_hwQkGOfBeV5gxQZrW4BB9niK8FwvoDB1cVjy4Ktw&quot;; //校验jwt令牌 Jwt jwt = JwtHelper.decodeAndVerify(token, new RsaVerifier(publickey)); //拿到jwt令牌中自定义的内容 String claims = jwt.getClaims(); System.out.println(claims); } ","link":"https://codeeLifer.github.io/post/rsa-suan-fa-shi-yong-si-yao-qian-ming-gong-yao-yan-qian/"},{"title":"跨域与如何解决跨域问题","content":" URL 说明 是否允许通信 http://www.a.com/a.js http://www.a.com/b.js 同一域名下 允许 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同一域名下不同文件夹 允许 http://www.a.com:8000/a.js http://www.a.com/b.js 同一域名，不同端口 不允许 http://www.a.com/a.js https://www.a.com/b.js 同一域名，不同协议 不允许 http://www.a.com/a.js http://70.32.92.74/b.js 域名和域名对应ip 不允许 http://www.a.com/a.js http://script.a.com/b.js 主域相同，子域不同 不允许 http://www.a.com/a.js http://a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问） http://www.cnblogs.com/a.js http://www.a.com/b.js 不同域名 不允许 解决办法： package net.youqu.micro.service.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.cors.CorsConfiguration; import org.springframework.web.cors.reactive.CorsWebFilter; import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource; import org.springframework.web.util.pattern.PathPatternParser; /** * description: * * @author slh * @date 2021.01.10 */ @Configuration public class CorsConfig { @Bean public CorsWebFilter corsFilter() { CorsConfiguration config = new CorsConfiguration(); config.addAllowedMethod(&quot;*&quot;); config.addAllowedOrigin(&quot;*&quot;); config.addAllowedHeader(&quot;*&quot;); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(new PathPatternParser()); source.registerCorsConfiguration(&quot;/**&quot;, config); return new CorsWebFilter(source); } } spring: cloud: gateway: discovery: # 跨域 globalcors: corsConfigurations: '[/**]': allowedHeaders: &quot;*&quot; allowedOrigins: &quot;*&quot; allowedMethods: - GET POST DELETE PUT OPTION ","link":"https://codeeLifer.github.io/post/kua-yu-yu-ru-he-jie-jue-kua-yu-wen-ti/"},{"title":"DFS算法总结 ","content":" 矩阵中的路径 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 例如，在下面的 3×4 的矩阵中包含单词 &quot;ABCCED&quot;（单词中的字母已标出）。 示例 1： 输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot; 输出：true javaimport java.util.HashMap; public class Solution { public static void main(String[] args) { HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); char[][] board = { // {'A', 'B', 'C', 'E'}, // {'S', 'F', 'C', 'S'}, // {'A', 'D', 'E', 'F'} {'a','b'} }; Solution solution = new Solution(); boolean bcfc = solution.exist(board, &quot;ba&quot;); System.out.println(bcfc); } public boolean exist(char[][] board, String word) { //初始化访问标记 boolean[][] visited = new boolean[board.length][board[0].length]; for (int i = 0; i &lt; board.length; i++) { for (int j = 0; j &lt; board[0].length; j++) { visited[i][j] = false; } } for (int i = 0; i &lt; board.length; i++) { for (int j = 0; j &lt; board[0].length; j++) { if (dfs(board,i,j,word,0,visited)) { return true; } } } return false; } public boolean dfs(char[][] board, int x, int y, String word, int pathLength, boolean[][] visited) { if (pathLength == word.length()) { return true; } boolean flag = false; if (x &gt;= 0 &amp;&amp; x &lt; board.length &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; board[0].length &amp;&amp; word.charAt(pathLength) == board[x][y] &amp;&amp; !visited[x][y]) { pathLength++; visited[x][y] = true; System.out.println(board[x][y]); flag = dfs(board, x + 1, y, word, pathLength, visited) || dfs(board, x, y + 1, word, pathLength, visited) || dfs(board, x - 1, y, word, pathLength, visited) || dfs(board, x, y - 1, word, pathLength, visited); visited[x][y] = false; } return flag; } } 不同路径 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ class Solution { public int uniquePaths(int m, int n) { Map&lt;String,Integer&gt; resultMap = new HashMap&lt;&gt;(); return dfs(resultMap,1,1,m,n); } public int dfs(Map&lt;String, Integer&gt; map,int x ,int y,int m ,int n){ String s = x + &quot;*&quot; + y; if(map.containsKey(s)){ return map.get(s); } if(x &gt; m || y &gt; n ){ return 0; } if(x == m &amp;&amp; y == n){ return 1; } int result = dfs(map,x+1,y,m,n) + dfs(map,x,y+1,m,n); map.put(s,result); return result; } } ","link":"https://codeeLifer.github.io/post/dfs-lei-suan-fa-ti-zong-jie/"},{"title":"java面试重点","content":" Java基础面试专题 1. java基础 ","link":"https://codeeLifer.github.io/post/java-mian-shi-chong-dian/"},{"title":"Hello poolMan!","content":"我的GitHub 博客主页 示例网站 ","link":"https://codeeLifer.github.io/post/hello-gridea/"}]}