{"posts":[{"title":"Java多态原理","content":" java中的多态分为编译时多态与运行时多态 首先理解java中的方法调用——静态绑定与动态绑定的区别 在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。 静态链接： 当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。 动态链接： 如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态 性，因此也就被称之为动态链接。 对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。 早期绑定：早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。 晚期绑定：如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。 编译时多态 编译期间决定目标方法 通过重载来实现 方法名相同，参数不相同 运行时多态 运行期间决定目标方法 通过重写和继承实现 java重写本质 找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。 如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.1ang.IlegalAccessError 异常 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError IlegalAccessError介绍：程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。 虚方法表 在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表（virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。 每个类中都有一个虚方法表，表中存放着各个方法的实际入口。 那么虚方法表什么时候被创建？ 虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。 ","link":"https://codeeLifer.github.io/post/java-duo-tai-yuan-li/"},{"title":"如何打破双亲委派类加载模型？","content":" 使用线程上下文类加载器 双亲委托机制以及类加载器的问题 一般情况下，保证同一个类中所关联的其他类都是由当前类的类加载器所加载的。比如，ClassA本身在Ext下找到，那么他里面new出来的一些类也就只能用Ext去查找了（不会低一个级别），所以有些明明App可以找到的，却找不到了。 JDBC API，他有实现的driven部分（mysql/sql server），我们的JDBC API都是由Boot或者Ext来载入的，但是JDBC driver却是由Ext或者App来载入，那么就有可能找不到driver了（因为驱动类是第三方厂商实现的，他们的包并没有与接口类放在一起，因此启动类与扩展类加载器找不到该类，从而导致加载失败）。在Java领域中，其实只要分成这种Api+SPI（Service Provide Interface，特定厂商提供）的，都会遇到此问题，常见的SPI有JDBC、JCE、JNDI、JAXP和JBI等。这些SPI的接口由Java核心库来提供，如JAXP的SPI接囗定义包含在javax.xml.parsers包中，SPI的接口是Java核心库的一部分，是由引导类加载器来加载的；SPI实现的Java类一般是由系统类加载器来加载的。引导类加载器是无法找到SPI的实现类的，因为它只加载Java的核心。 通常当你需要动态加载资源的时候，你至少有三个ClassLoader可以选择： 1. 系统类加载器或叫作应用类加载器（system classloader or application classloader） 2. 当前类加载器 3. 当前线程类加载器 线程类加载器是为了抛弃双亲委派加载链模式。每个线程都有一个关联的上下文类加载器。如果你使用new Thread0方式生成新的线程，新线程将继承其父线程的上下文类加载器。如果程序对线程上下文类加载器没有任何改动的话，程序中所有的线程将都使用系统类加载器作为上下文类加载器。 Thread.currentThread0.getContextClassLoader（） Thread.currentThread0.setContextClassLoader（） 如何不对当前线程的类加载器设置的话，则当前线程的默认加载器默认是应用类加载器ApplicationContextClassLoader ","link":"https://codeeLifer.github.io/post/ru-he-da-po-shuang-qin-wei-pai-lei-jia-zai-mo-xing/"},{"title":"Cookie与Session","content":" 会话：一次会话中包含多次请求和响应。 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 功能：在一次会话的范围内的多次请求间，共享数据 方式： 客户端会话技术：Cookie 服务器端会话技术：Session Cookie快速入门： 使用步骤： 创建Cookie对象，绑定数据 new Cookie(String name, String value) 发送Cookie对象 response.addCookie(Cookie cookie) 获取Cookie，拿到数据 Cookie[] request.getCookies() 实现原理 基于响应头set-cookie和请求头cookie实现 cookie的细节 一次可不可以发送多个cookie? 可以 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。 cookie在浏览器中保存多长时间？ 默认情况下，当浏览器关闭后，Cookie数据被销毁 持久化存储： setMaxAge(int seconds) 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效 负数：默认值 零：删除cookie信息 cookie能不能存中文？ 在tomcat 8 之前 cookie中不能直接存储中文数据。 需要将中文数据转码---一般采用URL编码(%E3) 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析 cookie共享问题？ 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？ 默认情况下cookie不能共享 setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目 如果要共享，则可以将path设置为&quot;/&quot; 不同的tomcat服务器间cookie共享问题？ * setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享 * setDomain(&quot;.baidu.com&quot;),那么tieba.baidu.com和news.baidu.com中cookie可以共享 Cookie的特点和作用 cookie存储数据在客户端浏览器 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) 作用： cookie一般用于存出少量的不太敏感的数据 在不登录的情况下，完成服务器对客户端的身份识别 ","link":"https://codeeLifer.github.io/post/cookie-yu-session/"},{"title":"RSA算法——使用私钥签名，公钥验签","content":"1 加密技术 1.1 对称加密与非对称加密 加密技术是最常见的安全保密手段，数据加密技术的关键在于加密/解密算法和密钥管理。数据加密的基本过程是对原来为明文的文件或数据按某种加密算法进行处理，使其成为不可读的一段代码，通常称为“密文”。“密文”只能在输入相应的密钥之后才能显示出原来的内容，通过这样的途径保证被加密的内容不被窃取。 对称加密的特点是文件或数据加密和解密使用相同的密钥，这种方法在密码学中称为对称加密算法。 非对称加密算法区别于对称加密算法，非对称加密算法需要两个密钥，公钥（Publickey）和私钥（PrivateKey）。公钥与私钥是一对，如果使用公钥对数据加密，需要对应的私钥才能解密；如果使用私钥对数据加密，需要对应的公钥才能解密。 1.2 加密与签名 非对称加密有两种用法。第一种用法是公钥加密、私钥解密——用于加密；第二种用法是私钥签名、公钥验签——用于签名。 什么时候用公钥，什么时候用私钥是经常被问起的问题。 第一种情况，当用于加密时，肯定是不想让别人知道我加密的内容，此时用于解密的肯定是私钥。比如A需要B发送一个加密后的数据过来，B知道A的公钥，C也知道A的公钥，A将数据使用A的公钥加密后发送出去，A获得了加密后的数据并用A的私钥解密，而如果C也想获取这一个数据，但是C没有A的私钥也是获取不了的。 第二种情况，用于签名。这里签名的意思是证明这个数据时由“我”发出的，要证明这一个数据由“我”发出，那肯定要用私钥加密，也就是签名，其他人获取这一加密数据后用“我”的公钥解密，也就是校验这一个签名。这里举一个例子，在一个“商城系统”微服务中，客户端请求用户认证微服务，获取到了一个私钥加密的token，这个token就是“商城系统”的签名，拿到这一个token的客户端携带token访问“商城系统”的其他微服务，其他微服务对这个客户端的请求进行拦截并使用“商城系统”的公钥校验token，如果通过验证才允许请求继续进行。 1.3 使用Spring Security实现私钥签名，公钥验签功能 私钥签名 /** * 读取证书文件中的私钥，并使用私钥对数据加密，得到加密后的字符串 */ @Test public void testGenerateToken(){ String keystore = &quot;mountain.keystore&quot;; String keystorePassword = &quot;mountainkeystore&quot;; ClassPathResource classPathResource = new ClassPathResource(keystore); String alias = &quot;mountainkey&quot;; String keyPassword = &quot;mountain&quot;; KeyStoreKeyFactory keyStoreKeyFactory = new KeyStoreKeyFactory(classPathResource,keystorePassword.toCharArray()); KeyPair keyPair = keyStoreKeyFactory.getKeyPair(alias, keyPassword.toCharArray()); RSAPrivateKey aPrivate = (RSAPrivateKey) keyPair.getPrivate(); Map&lt;String,String&gt; contentMap = new HashMap&lt;&gt;(); contentMap.put(&quot;hello&quot;,&quot;hello world&quot;); String bodyString = JSON.toJSONString(contentMap); Jwt jwt = JwtHelper.encode(bodyString, new RsaSigner(aPrivate)); String encodedContent = jwt.getEncoded(); System.out.println(encodedContent); } 公钥验签 /** * 使用公钥校验加密后的字符串 */ @Test public void testCheckTokenByPublicKey() { // 公钥 String publickey = &quot;-----BEGIN PUBLIC KEY-----&quot; + &quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtbuddIbMU5FjqpJR4Ikn&quot; + &quot;xktq1k/0C10XfOR2VU79qh4PXGSNn6Vt5BZgK8Ow4cA7SzAMoBUkxev/5I2Mx4p4&quot; + &quot;gk+6ImQ+IsTi6tqXOQ7DHjpogfsX/VeXJ93Aeq8v9hOqtKYj5q1jy4skGRvbD+c8&quot; + &quot;Z6knxLQb9I6HE39v3BZZL+WTYz6kx8BTZ0rPd7C5uOVqYo/FG+QzY+Ndv2u7gNcy&quot; + &quot;V9sRnM+hI2w5e87LuG+V6GhekdKqtS0dsjKskpjX/L2ppykdi1hkCtS/ipZ5aaAj&quot; + &quot;/SzVfWfQTxw4Yh+3QVc+KoSW61KlCZ+SSu7YrszAqlg93927/eWWLjYUFsCqP0jw&quot; + &quot;5wIDAQAB&quot; + &quot;-----END PUBLIC KEY-----&quot;; // 私钥加密后的内容 String token = &quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJoZWxsbyI6ImhlbGxvIHdvcmxkIn0.LNB7GpiTYl1G4MNYpFDPgay6funMLXeoGUo3TU30IfhIJiSU7zobJ-SpJap6ARbCJoRc5_JURb4ti-6vanf3cpIyOayk2H83gfBOSY8_wACbpfhlt_PGT0RYfStGC7OVwKFUAdEaO6hYYD466vI8d6d9uNb1RfNfGToYlosH05McYAyrM2XLcy0T7glZmuNw_JgMflRAjN09K13MlQZttn6W-lhSlv38CE1_CJ8SzNLHC6U7Dzd1FlcW9Xs-IvDalw1xzgzNRfbNpdvcZTnNhbdNa6_bSlSIfSM9IHngG3EVS_hwQkGOfBeV5gxQZrW4BB9niK8FwvoDB1cVjy4Ktw&quot;; //校验jwt令牌 Jwt jwt = JwtHelper.decodeAndVerify(token, new RsaVerifier(publickey)); //拿到jwt令牌中自定义的内容 String claims = jwt.getClaims(); System.out.println(claims); } ","link":"https://codeeLifer.github.io/post/rsa-suan-fa-shi-yong-si-yao-qian-ming-gong-yao-yan-qian/"},{"title":"跨域与如何解决跨域问题","content":" URL 说明 是否允许通信 http://www.a.com/a.js http://www.a.com/b.js 同一域名下 允许 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同一域名下不同文件夹 允许 http://www.a.com:8000/a.js http://www.a.com/b.js 同一域名，不同端口 不允许 http://www.a.com/a.js https://www.a.com/b.js 同一域名，不同协议 不允许 http://www.a.com/a.js http://70.32.92.74/b.js 域名和域名对应ip 不允许 http://www.a.com/a.js http://script.a.com/b.js 主域相同，子域不同 不允许 http://www.a.com/a.js http://a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问） http://www.cnblogs.com/a.js http://www.a.com/b.js 不同域名 不允许 解决办法： package net.youqu.micro.service.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.cors.CorsConfiguration; import org.springframework.web.cors.reactive.CorsWebFilter; import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource; import org.springframework.web.util.pattern.PathPatternParser; /** * description: * * @author slh * @date 2021.01.10 */ @Configuration public class CorsConfig { @Bean public CorsWebFilter corsFilter() { CorsConfiguration config = new CorsConfiguration(); config.addAllowedMethod(&quot;*&quot;); config.addAllowedOrigin(&quot;*&quot;); config.addAllowedHeader(&quot;*&quot;); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(new PathPatternParser()); source.registerCorsConfiguration(&quot;/**&quot;, config); return new CorsWebFilter(source); } } spring: cloud: gateway: discovery: # 跨域 globalcors: corsConfigurations: '[/**]': allowedHeaders: &quot;*&quot; allowedOrigins: &quot;*&quot; allowedMethods: - GET POST DELETE PUT OPTION ","link":"https://codeeLifer.github.io/post/kua-yu-yu-ru-he-jie-jue-kua-yu-wen-ti/"},{"title":"DFS算法总结 ","content":" 矩阵中的路径 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 例如，在下面的 3×4 的矩阵中包含单词 &quot;ABCCED&quot;（单词中的字母已标出）。 示例 1： 输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot; 输出：true javaimport java.util.HashMap; public class Solution { public static void main(String[] args) { HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); char[][] board = { // {'A', 'B', 'C', 'E'}, // {'S', 'F', 'C', 'S'}, // {'A', 'D', 'E', 'F'} {'a','b'} }; Solution solution = new Solution(); boolean bcfc = solution.exist(board, &quot;ba&quot;); System.out.println(bcfc); } public boolean exist(char[][] board, String word) { //初始化访问标记 boolean[][] visited = new boolean[board.length][board[0].length]; for (int i = 0; i &lt; board.length; i++) { for (int j = 0; j &lt; board[0].length; j++) { visited[i][j] = false; } } for (int i = 0; i &lt; board.length; i++) { for (int j = 0; j &lt; board[0].length; j++) { if (dfs(board,i,j,word,0,visited)) { return true; } } } return false; } public boolean dfs(char[][] board, int x, int y, String word, int pathLength, boolean[][] visited) { if (pathLength == word.length()) { return true; } boolean flag = false; if (x &gt;= 0 &amp;&amp; x &lt; board.length &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; board[0].length &amp;&amp; word.charAt(pathLength) == board[x][y] &amp;&amp; !visited[x][y]) { pathLength++; visited[x][y] = true; System.out.println(board[x][y]); flag = dfs(board, x + 1, y, word, pathLength, visited) || dfs(board, x, y + 1, word, pathLength, visited) || dfs(board, x - 1, y, word, pathLength, visited) || dfs(board, x, y - 1, word, pathLength, visited); visited[x][y] = false; } return flag; } } 不同路径 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ class Solution { public int uniquePaths(int m, int n) { Map&lt;String,Integer&gt; resultMap = new HashMap&lt;&gt;(); return dfs(resultMap,1,1,m,n); } public int dfs(Map&lt;String, Integer&gt; map,int x ,int y,int m ,int n){ String s = x + &quot;*&quot; + y; if(map.containsKey(s)){ return map.get(s); } if(x &gt; m || y &gt; n ){ return 0; } if(x == m &amp;&amp; y == n){ return 1; } int result = dfs(map,x+1,y,m,n) + dfs(map,x,y+1,m,n); map.put(s,result); return result; } } ","link":"https://codeeLifer.github.io/post/dfs-lei-suan-fa-ti-zong-jie/"},{"title":"java面试重点","content":" Java基础面试专题 1. java基础 ","link":"https://codeeLifer.github.io/post/java-mian-shi-chong-dian/"},{"title":"Hello poolMan!","content":"我的GitHub 博客主页 示例网站 ","link":"https://codeeLifer.github.io/post/hello-gridea/"}]}